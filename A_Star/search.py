# DO NOT MODIFY THIS FILE, A SIMILAR FILE IS USED TO EVALUATE YOUR SUBMISSION, MODIFYING THIS FILE WILL RESULT IN ERRORS DURING EVALUATION

import numpy as np
import matplotlib.pyplot as plt
import random
from queue import PriorityQueue, Queue
import search_algorithms as sa

enable_GUI  = True

def generate_maze(map_size=20):
    maze = np.ones((map_size, map_size), dtype=int)  # Set all walls as obstacles initially
    costs = np.random.randint(1, 4, size=(map_size, map_size))  # Set edge costs
    
    # Create a clear area inside the walls
    maze[1:-1, 1:-1] = 0
    
    num_obstacles = 3  # Fixed number of obstacles
    obstacle_width = 1
    obstacle_length = 12
    
    #obstacle 1
    x = 5
    y = 0
    maze[x:x + obstacle_width, y:y + obstacle_length] = 1
    #obstacle 2
    x = 15
    y = map_size - obstacle_length
    maze[x:x + obstacle_width, y:y + obstacle_length] = 1
    #obstacle 3
    x = 10
    y = 5
    maze[x:x + obstacle_width, y:y + obstacle_length] = 1
    #obstacle 4
    x = 5
    y = 14
    maze[x:x + 6, y:y+1] = 1

    # for i in range(num_obstacles):
    #     x = (i + 1) * (map_size // (num_obstacles + 1))  # Equally spaced obstacles
    #     y = 0 if i % 2 == 0 else map_size - obstacle_length  # Alternate vertical walls
        
    #     maze[x:x + obstacle_width, y:y + obstacle_length] = 1  # Set horizontal obstacle
    
    def is_valid_start_goal(start, goal):
        return np.linalg.norm(np.array(start) - np.array(goal)) >= 20
    
    start = (np.random.randint(1, 5), np.random.randint(1, map_size/2 - 1))
    goal = (np.random.randint(16, map_size - 1), np.random.randint(map_size/2, map_size - 1))
    while maze[start] == 1 or maze[goal] == 1 or start == goal or not is_valid_start_goal(start, goal):
        start = (np.random.randint(1, 5), np.random.randint(1, map_size/2 - 1))
        goal = (np.random.randint(16, map_size - 1), np.random.randint(map_size/2, map_size - 1))

    return maze, costs, start, goal

def main():
    maze, costs, start, goal = generate_maze()
    print('Start = ', start );
    print('Goal = ', goal );

    a_star_manhattan_path = sa.a_star(maze, start, goal, costs, 0)
    print('Path generated by yor a* aglorithm with manhattan heuristic is:', a_star_manhattan_path, ' with length = ', len(a_star_manhattan_path))
    
    a_star_euclidean_path = sa.a_star(maze, start, goal, costs, 1)
    print('Path generated by yor a* aglorithm with euclidean heuristic is:', a_star_euclidean_path, ' with length = ', len(a_star_euclidean_path))

    a_star_weighted_path = sa.a_star(maze, start, goal, costs, 5)
    print('Path generated by yor a* aglorithm with weighted heuristic is:', a_star_weighted_path, ' with length = ', len(a_star_weighted_path))

    if enable_GUI == True:
        fig, axes = plt.subplots(1, 3, figsize=(18, 6))
        titles = ["Manhattan Heuristic", "Euclidean Heuristic", "Weighted Heuristic"]
        paths = [a_star_manhattan_path, a_star_euclidean_path, a_star_weighted_path]
        
        for i, (path, ax) in enumerate(zip(paths, axes)):
            ax.imshow(maze, cmap='gray_r')
            ax.scatter(start[1], start[0], color='blue', s=50, label='Start')
            ax.scatter(goal[1], goal[0], color='red', s=50, label='Goal')
            if path:
                px, py = zip(*path)
                ax.plot(py, px, color='red', linewidth=2)
            ax.set_title(titles[i])
            ax.set_xlabel("Y-axis")
            ax.set_ylabel("X-axis")
            ax.legend()
            ax.set_xticks(np.arange(0, maze.shape[1], 1))
            ax.set_yticks(np.arange(0, maze.shape[0], 1))
            ax.grid(True, which='both', linestyle='--', linewidth=0.5)
        
        plt.show()

if __name__ == "__main__":
    main()